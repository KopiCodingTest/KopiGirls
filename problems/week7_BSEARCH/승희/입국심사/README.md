## 💻 Problem

### **문제 설명**

n명이 입국심사를 위해 줄을 서서 기다리고 있습니다. 각 입국심사대에 있는 심사관마다 심사하는데 걸리는 시간은 다릅니다.

처음에 모든 심사대는 비어있습니다. 한 심사대에서는 동시에 한 명만 심사를 할 수 있습니다. 가장 앞에 서 있는 사람은 비어 있는 심사대로 가서 심사를 받을 수 있습니다. 하지만 더 빨리 끝나는 심사대가 있으면 기다렸다가 그곳으로 가서 심사를 받을 수도 있습니다.

모든 사람이 심사를 받는데 걸리는 시간을 최소로 하고 싶습니다.

입국심사를 기다리는 사람 수 n, 각 심사관이 한 명을 심사하는데 걸리는 시간이 담긴 배열 times가 매개변수로 주어질 때, 모든 사람이 심사를 받는데 걸리는 시간의 최솟값을 return 하도록 solution 함수를 작성해주세요.

### 제한사항

- 입국심사를 기다리는 사람은 1명 이상 1,000,000,000명 이하입니다.
- 각 심사관이 한 명을 심사하는데 걸리는 시간은 1분 이상 1,000,000,000분 이하입니다.
- 심사관은 1명 이상 100,000명 이하입니다.

### 입출력 예

| n   | times   | return |
| --- | ------- | ------ |
| 6   | [7, 10] | 28     |

<br/>

## 💡 Solution

- 이진탐색 사용했습니다! 연서가 세션때 알려준 예시코드의 많은 도움을 받았어요
- 이진탐색과 정렬은 짝궁이다! 무조건 0순위로 정렬부터 해줘야한다는걸 기억해야할 것 같아요
- 이진탐색의 핵심은, 범위를 쪼개는 **조건** 인것 같아요. 어떤 조건일 경우 오른쪽/왼쪽 범위로 탐색이어갈지!

```js
function solution(n, times) {
  times.sort((a, b) => a - b); // 심사시간 배열을 오름차순으로 정렬 (이진탐색 전 필수코스)
  let left = 1; // 최소 경우 : n명의 손님을 n명 이상의 심사관이 1분동안 처리
  let right = n * times[times.length - 1]; // 최대 경우 : n명의 손님을 1명의 심사관이 최대시간동안 처리
  let answer = right;
  while (left <= right) {
    // 이진탐색 종료 조건 : left 포인터가 right 포인터를 넘어서는 순간
    let mid = Math.floor((left + right) / 2); // 중간값 설정
    let count = 0;
    times.forEach((value) => {
      // 각 심사위원 심사 시간에 따라
      count += Math.floor(mid / value); // 각 심사위원이 몇명을 심사할 수 있는지 count
      if (count >= n) {
        answer = Math.min(mid, answer); // 최솟값
        return;
      }
    });
    if (count >= n) {
      // 중간값 기준 왼쪽 범위를 다시 이진탐색
      right = mid - 1;
    } else {
      // 중간값 기준 오른쪽 범위를 다시 이진탐색
      left = mid + 1;
    }
  }
  return answer;
}
```
