## 💻 Problem

n개의 음이 아닌 정수들이 있습니다. 이 정수들을 순서를 바꾸지 않고 적절히 더하거나 빼서 타겟 넘버를 만들려고 합니다. 예를 들어 [1, 1, 1, 1, 1]로 숫자 3을 만들려면 다음 다섯 방법을 쓸 수 있습니다.

```
-1+1+1+1+1 = 3
+1-1+1+1+1 = 3
+1+1-1+1+1 = 3
+1+1+1-1+1 = 3
+1+1+1+1-1 = 3
```

사용할 수 있는 숫자가 담긴 배열 numbers, 타겟 넘버 target이 매개변수로 주어질 때 숫자를 적절히 더하고 빼서 타겟 넘버를 만드는 방법의 수를 return 하도록 solution 함수를 작성해주세요.

**제한사항**

- 주어지는 숫자의 개수는 2개 이상 20개 이하입니다.
- 각 숫자는 1 이상 50 이하인 자연수입니다.
- 타겟 넘버는 1 이상 1000 이하인 자연수입니다.

**입출력 예**
| numbers | target | return |
| --------- | ------ | -------- |
| [1, 1, 1, 1, 1] | 3 | 5 |
| [4, 1, 2, 1] | 4 | 2 |

**입출력 예 설명**
입출력 예 #1

문제 예시와 같습니다.

입출력 예 #2

```
+4+1-2+1 = 4
+4-1+2-1 = 4
```

총 2가지 방법이 있으므로, 2를 return 합니다.

<hr>

### 📍 **정리** :

- 주어진 모든 숫자에 + 연산과 - 연산을 하는 경우를 탐색해 타겟 숫자가 나오는 횟수를 카운트한다
- 즉, 주어진 숫자 n개는 +와 -가 각각 될 수 있는 두 가지 경우의 수가 있으므로 총 2^n번의 탐색이 일어난다
- dfs 알고리즘을 이용해 전체 숫자가 + & - 일 모든 경우의 수를 탐색한다.

<br/>

## 💡 Solution

```js
function solution(numbers, target) {
  let answer = 0;

  // 1. dfs 함수에 0,0 넘겨주기
  dfs(0, 0);

  // 2. dfs 함수
  function dfs(level, sum) {
    if (level === numbers.length) {
      if (sum === target) {
        answer += 1;
      }
      return;
    }
    // 3. 레벨 하나씩 올려 dfs 수행
    dfs(level + 1, sum + numbers[level]);
    dfs(level + 1, sum - numbers[level]);
  }

  return answer;
}
```

### 코드 설명 :

0. dfs를 정수의 개수만큼 재귀호출하여 각각의 수를 + 했을 때, - 했을 때의 모든 경우를 탐색한다.
1. dfs 함수에 루트 노드의 인덱스와 연산 결과의 합을 각각 0으로 설정해 넘겨준다.
2. dfs 함수 : 인덱스가 배열의 길이와 같으면, 배열의 맨 마지막 요소까지 모두 순회했다는 뜻이므로 만약 합이 target과 같다면 answer를 하나 증가시키고, 그렇지 않으면 함수를 빠져나온다.
3. 인덱스가 배열을 모두 순회하기 전 순서대로 인덱스(=레벨)을 하나씩 올려주어 dfs를 수행한다. 이때, '+'를 계산하는 함수(sum과 number의 숫자 하나를 꺼내 합을 계산한 값을 인수로 준다) / '-'를 계산하는 함수(sum과 numbers의 숫자 하나를 꺼내 차를 계산한 값을 인수로 준다)를 각각 수행한다.

### 참고자료 :

- [찾은 모범 답안](https://jjnooys.medium.com/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-%ED%83%80%EA%B2%9F-%EB%84%98%EB%B2%84-javascript-1d7983d423b5)
- [트리 형태로 답안 풀이](https://yong-nyong.tistory.com/41)
